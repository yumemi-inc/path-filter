name: 'Path Filter'
description: 'A GitHub Action to filter changed files in pull requests and commits.'
author: 'YUMEMI Inc.'
branding:
  icon: 'filter'
  color: 'blue'
inputs:
  patterns:
    description: 'Path pattern to filter. See README for details.'
    required: false
  run:
    description: 'Bash script to run if at least one file exists after filtering.'
    required: false
  head-ref:
    description: 'Current branch, tag, or commit SHA to compare with base.'
    required: false
    default: ${{ github.sha }}
  base-ref:
    description: 'Branch, tag, or commit SHA as a basis for comparison.'
    required: false
    default: ':default:'
outputs:
  exists:
    description: 'Whether at least one file exists after filtering.'
    value: ${{ steps.filter.outputs.result }}
  action-path:
    description: 'Used to access artifact files.'
    value: ${{ steps.prepare.outputs.action-path }}
runs:
  using: 'composite'
  steps:
    - name: Prepare
      id: prepare
      shell: bash
      env:
        PATTERNS: ${{ inputs.patterns }}
        HEAD_REF: ${{ inputs.head-ref }}
        BASE_REF: ${{ (github.event_name == 'push' && inputs.base-ref == ':default:' && inputs.head-ref == github.event.after && github.event.before) || (inputs.base-ref != ':default:' && inputs.base-ref) || '' }}
        REPO: ${{ github.repository }}
        TOKEN: ${{ github.token }}
      run: |
        echo "::debug::jq version: $(jq --version)"
        echo "action-path=$GITHUB_ACTION_PATH" >> "$GITHUB_OUTPUT"
        source "$GITHUB_ACTION_PATH/raise_error.sh"

        patterns="$("$GITHUB_ACTION_PATH/get_multiline_input.sh" "$PATTERNS")"

        if [ "$patterns" == '[]' ]; then raise_error "Specify 'patterns' input."; fi

        echo "patterns=$patterns" >> "$GITHUB_OUTPUT"

        if [ -z "$HEAD_REF" ]; then raise_error "Specify 'head-ref' input."; fi

        # ref: https://github.com/actions/checkout/blob/72f2cec99f417b1a1c5e2e88945068983b7965f9/src/git-auth-helper.ts#L55-L63
        git config --global 'http.https://github.com/.extraheader' "AUTHORIZATION: basic $(echo -n "x-access-token:$TOKEN"|base64)"

        # reuse sources for the same job
        if [ ! -d "$GITHUB_ACTION_PATH/sources" ]; then
          git clone -q --depth 1 "https://github.com/$REPO" "$GITHUB_ACTION_PATH/sources" > /dev/null 2>&1 || raise_error "May not have 'contents: read' permission."
        fi
        cd "$GITHUB_ACTION_PATH/sources"

        if [ -z "$BASE_REF" ]; then depth=2; else depth=1; fi
        git fetch -q --depth "$depth" origin "$HEAD_REF" > /dev/null 2>&1 || raise_error "'head-ref' input is not valid."
        head_sha="$(git rev-parse FETCH_HEAD)"

        if [ -z "$BASE_REF" ]; then
          base_sha="$(git rev-parse "${head_sha}~1")" > /dev/null 2>&1 || raise_error "No history. 'head-ref' input reference may be the first commit."
        else
          git fetch -q --depth 1 origin "$BASE_REF" > /dev/null 2>&1 || raise_error "'base-ref' input is not valid."
          base_sha="$(git rev-parse FETCH_HEAD)"
        fi

        # output large data to filles
        echo -n "$(git diff --name-only "$base_sha" "$head_sha" | jq -R | jq -cs)" > "$GITHUB_ACTION_PATH/files.json"
    - name: Filter files
      id: filter
      uses: actions/github-script@v7
      env:
        PATTERNS: ${{ steps.prepare.outputs.patterns }}
      with:
        script: |
          const { GITHUB_ACTION_PATH, PATTERNS } = process.env;
          const fs = require('fs'), minimatch = require(`${GITHUB_ACTION_PATH}/dist/index.js`);
          const files = JSON.parse(fs.readFileSync(`${GITHUB_ACTION_PATH}/files.json`, 'utf-8')), patterns = JSON.parse(PATTERNS);
          const incPatterns = patterns.filter(p => !p.startsWith('!'));
          const excPatterns = patterns.filter(p => p.startsWith('!')).map(p => p.slice(1));
          const option = { dot: true, nocomment: true, nonegate: true, noext: true };
          const filteredFiles = files.filter(f => incPatterns.length === 0 || incPatterns.some(p => minimatch(f, p, option)))
            .filter(f => !excPatterns.some(p => minimatch(f, p, option)));
          fs.writeFileSync(`${GITHUB_ACTION_PATH}/filtered_files.json`, JSON.stringify(filteredFiles), 'utf-8');
          return filteredFiles.length !== 0;          
    - name: Run script
      if: steps.filter.outputs.result == 'true' && inputs.run != null
      shell: bash
      run: |
        ${{ inputs.run }}
